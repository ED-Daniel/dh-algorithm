# Протокол Диффи-Хеллмана: конспект

## 1. Математические основы

### Дискретное логарифмирование
В мультипликативной группе $\mathbb{Z}_p^*$ (целые числа по модулю простого $p$) задача дискретного логарифмирования формулируется так: дано $g$, $A$ и $p$, найти $a$ такое, что $g^a \equiv A \pmod{p}$. Для больших $p$ эта задача считается вычислительно трудной.

### Генератор группы
Элемент $g$ называется генератором $\mathbb{Z}_p^*$, если его степени порождают все ненулевые элементы по модулю $p$. Порядок группы равен $p - 1$.

## 2. Протокол Диффи-Хеллмана

### Цель
Позволить двум сторонам (Alice и Bob) выработать общий секретный ключ по открытому каналу связи.

### Шаги протокола

1. **Общие параметры** (публичные): простое $p$ и генератор $g$
2. **Alice**: выбирает секретное $a$, вычисляет $A = g^a \bmod p$, отправляет $A$ Бобу
3. **Bob**: выбирает секретное $b$, вычисляет $B = g^b \bmod p$, отправляет $B$ Алисе
4. **Общий секрет**:
   - Alice вычисляет $K = B^a \bmod p = g^{ab} \bmod p$
   - Bob вычисляет $K = A^b \bmod p = g^{ab} \bmod p$

Перехватчик видит $g$, $p$, $A$, $B$, но не может вычислить $K = g^{ab} \bmod p$ без решения задачи Диффи-Хеллмана (CDH).

### Безопасные параметры (Safe Prime)
Безопасное простое: $p = 2q + 1$, где $q$ тоже простое. В этом случае $p - 1 = 2q$ имеет только два простых делителя (2 и $q$), что исключает атаки через малые подгруппы.

## 3. Атака на слабые параметры (Small Subgroup Attack)

### Суть уязвимости
Если $p - 1$ содержит малый простой делитель $q$, атакующий может извлечь частичную информацию о секретном ключе.

### Алгоритм атаки

1. Пусть $q \mid (p - 1)$ — малый простой делитель
2. Вычисляем проекцию публичного ключа в подгруппу порядка $q$:
   $$A' = A^{(p-1)/q} \bmod p$$
3. Вычисляем генератор подгруппы:
   $$g' = g^{(p-1)/q} \bmod p$$
4. Перебираем $x$ от 0 до $q - 1$: если $g'^x \equiv A' \pmod{p}$, то
   $$a \equiv x \pmod{q}$$

### Сложность
Перебор занимает $O(q)$ операций. Для малых $q$ (например, $q = 23$) это тривиально.

### Комбинирование (CRT)
Если $p - 1$ имеет несколько малых делителей $q_1, q_2, \ldots$, атакующий восстанавливает $a \bmod q_i$ для каждого и применяет Китайскую теорему об остатках (CRT), чтобы получить $a \bmod (q_1 \cdot q_2 \cdots)$.

## 4. Результаты сравнения производительности

| Параметр | $p \approx 2^{32}$ | $p \approx 2^{1024}$ | Разница |
|---|---|---|---|
| Генерация параметров (safe prime) | 0.0005 с | ~792 с | ~1 553 879x |
| DH обмен (ключи + общий секрет) | 0.000016 с | 0.015 с | ~900x |

**Наблюдения:**
- Генерация safe prime — самая затратная операция, растёт экспоненциально с размером $p$
- Модульное возведение в степень (сам обмен) масштабируется значительно лучше
- $p \approx 2^{1024}$ — минимальный рекомендуемый размер; $2^{2048}$ для долгосрочной безопасности

## 5. Выводы

1. **Выбор параметров критичен**: использование safe prime ($p = 2q + 1$) защищает от атак через малые подгруппы
2. **Проверка параметров обязательна**: перед использованием DH необходимо проверить, что $p$ — простое и $g$ — генератор нужного порядка
3. **Размер ключа**: минимум 1024 бита для $p$; рекомендуется 2048+ бит для стойкости против современных алгоритмов (GNFS)
4. **Атака реальна**: при слабых параметрах секретный ключ (или его часть) восстанавливается за доли секунды
5. **Компромисс**: безопасность требует вычислительных затрат, но стоимость DH-обмена остаётся приемлемой даже для больших ключей

## Использованные библиотеки
- `sympy` — проверка простоты (`isprime`), факторизация (`factorint`), поиск следующего простого (`nextprime`)
- `secrets` — криптографически стойкая генерация случайных чисел
- `time` — замеры производительности
